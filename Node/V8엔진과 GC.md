# node 엔진 관련

# V8 엔진이란?

- c++ 로 개발된 Google의 Js 및 WebAssembly 기반 오픈소스 엔진
- `JIT` (just-in-time comepilation) 을 사용해 JS 코드를 실행
    - 즉, JS 코드를 컴파일하고 실행하는 엔진이며 Chrome 및 Node.js에서 사용됨
- V8엔진은 인터프릿 방식을 채택하였다.

## 컴파일(Complie)과 인터프릿(Interpret)

| **구분** | **인터프릿(Interpret)** | **컴파일(Compile)** |
| --- | --- | --- |
| 번역 | 한 줄씩 번역 후 실행 | 전체를 번역 한 번에 실행 |
| 장점 | 코드 전체가 컴파일 된 Compilation이 완선 되는 것을 기다릴 필요 없이
`한 줄 한 줄 변환`하기 때문에 `실행 속도가 빠르다` | 컴파일러는 `작업을 단순화`시키므로 효율적인 실행 코드가 생성된다.
(Optimizion 불필요한 동작을 제거하는 컴파일러 방식을 최적화)
ex) 특정 함수를 10억 번 반복해야 할 경우,
함수를 반복하지 않고 결과물을 반복하도록 컴파일한다. |
| 단점 | 실행시에 인터프리터가 항상 필요함 | 기계어에 종속적인 실행코드가 생성되므로 실행 기계가 달라지면 새로 컴파일해야 한다. |
| 언어 | Node.js, Python 등 | C, C++, JAVA 등 |
- 짧은 코드라면 Interpret 방식이 좋겠지만 대규모의 경우 JAVA와 같이 컴파일하여 개발해야 하는 게 아닌가라는 의문이 들 수 있다.
- 그렇다면 JIT가 어떻게 퍼포먼스를 낼 수 있을까
    
    ⇒ `Code Caching` 이라는 기술 덕분이다
    
    ---
    

## V8 엔진 Flow

![V8 엔진 Flow](./images/image%200.png)

V8 엔진 Flow

1. `JavaScript Source Code`
    - 사용자가 JavaScript 코드 작성하고 실행
2. `Parser`
    - AST(Abstract Syntax Tree)
    
    ![image.png](./images/image%201.png)
    
    - Parser에서 JavaScript Source Code를 분석 (Lexical Analysis 과정)을 거치고 AST로 변환함
3. `Ignition Interpreter`
    - AST를 BypeCode로 변환함
    - 처음에는 ByteCode로 변화하는 과정에서 많은 시간이 소요될 수 있으나 추후 컴파일에 가까운 성능을 보인다
    - 원본 소스코드보다 컴퓨터가 해석하기 쉬운 바이트코드로 변환함으로서 원본코드를 다시 파싱해야 하는 수고를 덜고
    - 코드의 양도 줄이면서 코드를 실행할 때 차지하는 메모리 공간을 아끼는 장점이 있다.

![image.png](./images/image%202.png)

1. `Complier TurboFan`
    - ByteCode를 실행하므러서 실제 우리의 코드가 작동하게 되고
    - 그 중 자주 사용되는 코드는 TurboFan으로 보내져서 Optimized Machine Code 즉, 최적화된 코드로 다시 컴파일된다.
    - Profiler는 최적화가 가능한 부분을 찾아서 기록해둔다.
    - JIT Compiler를 통해 엔진은 더 빠르게 실행하기 위해 최적화 피드백 데이터와 함께 컴파일러로 보낸다
    - 어떤 시점에서 가정 중 하나가 잘못 된 것으로 판명되거나 사용이 덜된다 싶으면 `Deoptimizing`한다.
    - 최적화 컴파일러는 최적화 해제하고 Interpret로 돌아간다.

## 요약

- `Interpreter 방식`으로 컴파일하고 이를 `ByteCode로 만든`다
- Compile 속도를 높이기 위해 `자주 쓰이는 ByteCode`를 `인라인 캐싱`(inline caching)과 같은 최적화 기법으로 `최적화`한다.
- 이런 방식을 `JIT`(Just-In-Time) Compiler 이라고 하며 Interpreter의 `느린 실행 속도를 개선하는 엔진의 핵심`이다
    - `JIT`는 OS에 구애받지 않고 컴파일러에 인터프리터가 들어가 속도가 빠르다
- Chrome은 동일한 스크립트가 며칠 내에 두 번 이상 표시되는 경우에만 캐시 데이터를 생성하도록 개발하였고
결과적으로 Chrome은 스크립트 파일을 실행 가능한 코드로 평균 2배 빠르게 변환할 수 있어서
사용자들이 지금과 같이 빠른 속도록 이용이 가능하다

# Gargabe Collection

- V8엔진에서 Code Caching이 핵심 기술이다 
그렇기 때문에 어떤 과정을 거치는지가 제일 중요하다
조금 더 자세히 알아보자

## V8의 역할

1. JavaScript 소스 코드를 컴파일 및 실행
2. 힙 메모리 객체에 대한 메모리 할당
3. `Garbage Collection`
4. 콜스택 핸들링

---

- 위의 역할 중 GC가 V8의 핵심 기능이라고 할 수 있다
- GC는 주기적으로 작업이 완료된 객체 정보를 수집하여 재사용할 수 있는 메모리로 전환하는 역할을 한다.ㅇ

## 아키텍처의 변화

2015년 공식 홈페이지에서 소개 되었던 아키텍처가 v8 5.0 엔진으로 고도화되면서 큰 변화가 생겼다.

그 코드 네임을 `Orinoco`라고 정의 했고 핵심적인 부분은 `메모리 영역을 두 가지 세그먼트로 분리했다`

- New space : Young generation
- Old space : Old generation

그림2에서 그림3 방식으로 포인터 업데이트 방식 구조가 병렬 형태로 변경 되었는데
아래의 구조를 보면 오브젝트가 힙에서 이동될 때 객체간의 포인터를 모두 순차적으로 업데이트 해주어야 했다.

![image.png](./images/image%203.png)

![image.png](./images/image%204.png)

그러다보니 버벅거리는 문제들이 많이 발생했다. 그러다보니 V8의 Orinoco에서는 3가지 최적화 방법을 도입했다

### 1. heap memory page 분리

1차적으로 `heap memory`라고 불리는 고정 사이즈 덩어리로 분할한다.
     이것을 `Young generation` 또는 `Old generation` 공간에 할당한다.
2차적으로 객체는 초기에 Y세대에 할당되며 GC시에 Y세대 내에서 한 번 이동 되고 
    다른 GC에서 살아남은 개체들은 O세대로 승격된다.

위의 1,2차를 Y세대 집합이라는 페이지를 기반으로 메모리 복사를 병렬화하고
Y세대 내에서의 개체 이동은 항상 새로운 페이지에 메모리를 할당 및 이전 페이지 해제를 하며
메모리 레이아웃을 압축한다.

그리고 O세대에서는 `죽은 메모리 찌꺼기를 남기`기 때문에 이 프로세스가 조금 다른 방식으로 발생한다.
찌꺼기 일부는 일부 재사용이 가능하지만 나머지는 새로운 Y세대 집합 페이지로 이동하기 위해 압축을 진행한다.

위와 같이 Young generation, Old generetion 압축 사이에 종속성이 없기 때문에 병렬로 처리 수행하며 이러한 개선 결과 압축 시간이 ~7m/s에서 2m/s 미만으로 75% 감소했다.

### 2. GC(Garbage Collaction) pointer 추척 방식 개선

개체가 힙에서 위치를 이동하게 되면 GC는 이동된 개체의 이전 위치를 포함하는
모든 포인터(pointer)들을 찾아 새로운 위치로 업데이트 해야 한다.
포인터들을 찾기 위해 힙(heap)을 반복하는 것은 성능을 매우 낮추기 때문에
V8은 메모리 집합이라는 데이터구조를 사용하여 힙에 있는 모든 포인터들을 추적한다.

> "힙 메모리"는 커다란 놀이터라고 생각해보자
> 
> 
> "포인터"들은 놀이터에 숨은 친구들을 찾는 지도이다.
> 
> 근데 갑자기 친구가 놀이터 안에서 자리를 이동했다
> 
> 그러면 지도(포인터)가 가리키는 위치도 바꿔어야 할 것이다.
> 
> 문제는, 놀이터 전체를 돌아다니면서 "지도 어디 있지?"라며 찾으면 **시간이 엄청 걸려서** 힘들 것이다.
> 
> 그래서 **V8 엔진**은 "메모리 집합"이라는 특별한 명단을 만들어 놓고
> 이 명단에는 "친구(포인터)가 어디 어디 숨어있다"는 정보가 **미리 다 정리**돼 있다.
> 
> 그러니까, 누가 이동하면,
> "어디에 친구들이 있는지" 힘들게 헤매지 않고 바로 찾아가서 **지도를 수정**하는 것이다.
> 

기존에는 아래의 사진과 같이 pointer addresses들을 arrays 또는 store buffers들로 구현했었다.

![image.png](./images/image%205.png)

위와 같이 페이지(page) 안에는 Y세대를 위한 하나의 Store Buffer와 
O세대의 찌꺼기가 있는 Store Buffer들이 있습니다.

Store Buffer의 저장 페이지에는 그림 4와 같이 모든 포인터들의 주소가 포함되어 있는데
이와 같이 아키텍처를 설계했을 때 store buffer가 포인터를 여러 번 포함할 수 있고
두 개의 서로 다은 store buffer가 동일한 포인터를 포함할 수 있기 때무에 중복될 수 있는 이슈가 있었다.
이 이슈는 동일한 포인터를 업데이트하려는 두 threads로 인해 발행하는 경합으로
포인터 업데이트 단계에서 병렬화를 어렵게 만드는 상황이었다.

위와 같은 이슈를 해결하고자 아래 그림5와 같이 

![image.png](./images/image%206.png)

Orinoco는 page 세트들을 재구성하여 병렬화를 단순화하고
thread가 업데이트할 분리된 포인터 세트를 얻도록 함으로서 이러한 복잡성을 제거함으로
GC 최대 일시 중지 시간이 42m/s에서 23m/s로 45% 감소 했다.

### 3. GC의 마킹 단계를 개선

마지막 단계는 `Black allocation`이라는 GC의 마킹 단계를 개선한다.

V8 5.1부터 제공하게 되었고 기존 세대인 `Mark-Sweep-Compact`는 메모리 사용에 좋지 않아 
이를 개선하기 위해 `Tri-color Mark-Sweep`를 적용하게 되었다.

내용을 간단하게 설명하면 활성화/비활성화 2단계에서 3단계로 늘어났다고 이해하면 좋다

**3-1) `mark-and-sweep`**

![image.png](./images/image%207.png)

위와 같이 mark-and-sweep는 수집 주기 동안을 제외하고는 항상 지워진다.

- 첫 번째 단계는 mark stage로 root set의 tree들을 순회하고 root에서 요청한 객체를 `사용중으로 표시`하는 단계이다
- 두 번째 단계에서는 sweep stage로 모든 메모리를 처음부터 끝까지 스캔하여 사용 사능한 모든 블록 떠는 사용된 블록을 검사한다.

사용중으로 표시되지 않은 항목은 메모리에서 해제되며,
사용중으로 표시된 개체의 경우 사용중 플래그가 지워지며 다음 주기를 준비한다.

mark-and-sweep의 방법은 수집 중에 전체 시스템을 일시적으로 중단하는 크리트컬한 이슈가 있고
시기를 일반적으로 예측할 수 없게 정지되어 일부 실시간이나 시간이 중요한 응용 프로그램의 경우 사용이 불가능 해질 수 있다.

또한 전체 작업 메모리를 두 번 검사해야 하므로 잠재적인 `Memory paging` 시스템에 문제가 발생할 수 있는 이슈를 가지고 있다.

---

**3-2) `Black alloction`**

- 첫 번째 단계는 `흰색`으로 표기되며 개체의 초기 상태를 의미
초기 단계는 메모리를 재활용할 후보인 개체 집합이라고 이해하자
- 두 번째 단계는 `회색`으로 개체가 `root set`에서 도달할 수 있고 검사를 받거나 검사중인 상태이다
즉, root set에 도달할 수 있지만 “흰색” 개체에 대한 참조룰 위해 아직 스캔되지 않은 모든 개체가 포함된다.
root set에 도달할 수 있으므로 GC이 불사능하고 스캔 후 `블랙`에 남게 된다.
- 세 번째 단계는 `블랙`으로 표기되면 개체 검사가 완료된 표시이다.

![image.png](./images/image%208.png)

위의 그림을 통해 알고리즘적 로직을 확인해보자

1. 회색 세트에서 개체를 선택하고 블랙세트로 이동을 한다.
2. 회색 세트를 참조하는 각 횐색 개체를 이동한다.
이렇게 하면 이 개체나 참조하는 개체가 모두 CG될 수 없다.
3. 회색 세트가 비워질 때까지 마지막 두 단계를 반복한다.
회색 세트가 비어 있으면 스캔이 완료된 것이다
블랙 개체는 root set에서 접근할 수 있는 반면에 흰색 개체는 접근할 수 없고 GC가 가능하다.

즉, root set에서 즉시 도달할 수 없는 모든 개체가 흰색 세트에 추가되고 개체가 흰색 → 회색
회색 → 블랙으로만 이동할 수 있기 때문에 알고리즘은 중요한 불변성을 유지하는 장점을 가지고 있다.
특히, `블랙 개체는 흰색 개체를 참조하지 않는다`
이렇게 하면 회색 세트가 비어 있으면 흰색 개체를 해제할 수 있다.

위에 mark-and-sweep에서는 시스템을 중단해야 하는 이슈가 있었는데
Black allocation(Tri-color marking) 도입으로 상당한 시간 동안 시스템을 중단하지 않고
즉석에서 수행할 수 있다는 부분이 시스템에서 필요에 따라가 아니라 주기적으로 GC를 진행할 수 있다는 장점이 생겼고 또한 이를 동해 V8중단 이슈를 해결했다.

### GC가 있는 것이 무조건 좋을까?

**GC의 장점:**

- 개발자가 메모리 직접 관리 안 해도 됨
- 메모리 누수, 버그, 뻗는 문제를 줄여줌
- 실수해도 어느 정도는 복구해줌
- 프로덕션(실제 서비스) 환경에서 안정성이 올라감

**GC의 단점:**

- **GC 타이밍**은 완벽하게 제어할 수 없어
    
    (언제 GC 돈다고 딱 못 찍음)
    
- **GC 도는 동안 살짝 성능 저하**가 있을 수 있음
- *리소스 많이 쓰는 앱(게임, 실시간 시스템 등)**은 오히려 개발자가 수동으로 메모리 관리하는 게 나을 때도 있음

**내 생각(개발자가 신경 안 쓰고도 좋은 성능 나면 좋다)**

> 현대 대부분의 웹, 서버 어플리케이션은
> 
> 
> GC 있는 게 **훨씬 이득**이야.
> 
> (우리가 굳이 메모리 직접 관리할 필요 없이, 좋은 성능 유지하면서, 빠르게 개발할 수 있으니까.)
> 

정리 한 줄 요약:

> "GC는 무조건 좋은 건 아니지만,
> 
> 
> **현대 소프트웨어 개발에서는 거의 필수 같은 존재**다."
> 

아래와 같은 방법들도 있다

- Node.js에서 GC 수동 트리거하는 방법
- V8 GC 최적화 방법

# 전체 요약

- 눌러서 확인
    
    ## 1. V8 엔진이 뭔데?
    
    - **구글이 만든 초고속 JS + WebAssembly 엔진**이야.
    - **C++로 개발**됐고, **Chrome 브라우저**랑 **Node.js**에서 돌아가.
    - **JIT(Just-In-Time) 컴파일**을 써서 **JS를 바로 기계어로 바꿔서** 빠르게 실행시켜줘.
    - 시작은 **인터프리터(한 줄씩 해석)** 방식으로 하고,
        - *자주 쓰이는 코드는 JIT 컴파일러(TurboFan)**로 다시 최적화해서 초고속 실행!
    
    > ✅ 요약:
    > 
    > 
    > 인터프리터처럼 빠르게 시작 + 컴파일러처럼 빠르게 최적화 = V8 미쳤다.
    > 
    
    ---
    
    ## 2. 컴파일(Compile) vs 인터프리트(Interpret)
    
    | 구분 | 인터프리트(Interpret) | 컴파일(Compile) |
    | --- | --- | --- |
    | 번역 방식 | 한 줄씩 읽어서 바로 실행 | 전체를 다 읽고 기계어로 바꾼 후 실행 |
    | 장점 | 빠른 시작 | 빠르고 최적화된 실행 |
    | 단점 | 느릴 수 있음 | 처음에 느림 |
    | 예시 언어 | JS, Python | C, C++, Java |
    
    > ✅ V8은 둘 다 쓴다. (시작은 인터프리트 → 최적화는 컴파일)
    > 
    
    ---
    
    ## 3. V8 엔진 작동 흐름 (Flow)
    
    1. **JS 코드 작성**
    2. **Parser**가 코드를 읽고 **AST(추상 구문 트리)**로 바꿔
    3. **Ignition 인터프리터**가 AST를 **ByteCode**로 변환
    4. **ByteCode**를 실행
    5. 자주 쓰는 코드 발견하면 → **TurboFan**이 **최적화된 머신 코드**로 컴파일
    6. 빠르게 실행!
    
    > ✅ 바이트코드 → 최적화된 머신코드 → JIT 덕분에 빠르다.
    > 
    
    ---
    
    ## 4. V8의 힙 메모리 관리와 GC (Garbage Collection)
    
    - **V8 엔진은 메모리 관리도 알아서 해줌** (우리가 신경 안 써도 됨!)
    - **힙(Heap)**: 객체들이 살아 있는 공간
    - **GC**: 쓰지 않는 객체를 찾아서 메모리를 해제하는 시스템
    
    V8의 **힙 구조**:
    
    - **New Space (Young Generation)**: 새로 만들어진 애들
    - **Old Space (Old Generation)**: 오래 살아남은 애들
    - (큰 덩치 → Large Object Space, 코드 저장용 → Code Space도 있음)
    
    ## 5. V8 GC 최적화
    
    V8은 과거에 GC할 때
    
    **힙 전체를 돌면서 포인터 업데이트** → **개빡세고 버벅거림** 😵‍💫
    
    그래서 `Orinoco 프로젝트`로 3가지 최적화 했어:
    
    ### (1) 힙 페이지 분리
    
    - 고정 크기 덩어리(Page)로 쪼갬
    - 새 객체 → New Space에
    - 살아남으면 → Old Space로 승격
    - 병렬로 복사하면서 메모리 정리 = **GC 시간 75% 감소**
    
    ### (2) 포인터 추적 개선
    
    - "메모리 집합(Remembered Set)"을 써서
    - 어디에 포인터가 있는지 미리 기록
    - 이동할 때만 딱 찾아서 업데이트 = **속도 개빠름**
    
    ### (3) GC 마킹 최적화 (Black Allocation)
    
    - `Tri-color Marking (흰색/회색/검은색)` 적용
    - 흰색: 죽은 애들 후보
    - 회색: 체크해야 할 애들
    - 검은색: 살아있는 애들
    - → **끊임없이 GC를 돌리면서도 시스템을 멈추지 않음**
        
        (실시간 시스템에도 문제 없음!)
        
    
    ---
    
    # 🔥 핵심 진짜 요약
    
    > V8은 인터프리트 + JIT 컴파일러 콤보로 빠름GC는 힙 메모리를 주기적으로 청소함Orinoco로 GC 병렬화 + 최적화해서 버벅임 거의 없음
    > 
    
    ---
    
    # 📣 그럼 **GC가 무조건 좋은 거야?** 에 대한 내 대답
    
    **아니야. 무조건 좋은 건 아님.** (하지만 대체로 "좋은 거" 맞아.)
    
    🧠 **GC의 장점:**
    
    - 개발자가 메모리 직접 관리 안 해도 됨 (개꿀)
    - 메모리 누수, 버그, 뻗는 문제를 줄여줌
    - 실수해도 어느 정도는 복구해줌
    - 프로덕션(실제 서비스) 환경에서 안정성이 올라감
    
    ⚠️ **GC의 단점:**
    
    - **GC 타이밍**은 완벽하게 제어할 수 없어
        
        (언제 GC 돈다고 딱 못 찍음)
        
    - **GC 도는 동안 살짝 성능 저하**가 있을 수 있음
    - *리소스 많이 쓰는 앱(게임, 실시간 시스템 등)**은 오히려 개발자가 수동으로 메모리 관리하는 게 나을 때도 있음
    
    🌟 **네 생각(개발자가 신경 안 쓰고도 좋은 성능 나면 좋다)**
    
    ===> **완전히 맞는 방향이야!**
    
    > 현대 대부분의 웹, 서버 어플리케이션은
    > 
    > 
    > GC 있는 게 **훨씬 이득**이야.
    > 
    > (우리가 굳이 메모리 직접 관리할 필요 없이, 좋은 성능 유지하면서, 빠르게 개발할 수 있으니까.)
    > 
    
    정리 한 줄 요약:
    
    > "GC는 무조건 좋은 건 아니지만,
    > 
    > 
    > **현대 소프트웨어 개발에서는 거의 필수 같은 존재**다."
    > 
    
    ---
    
    # ✨ 추가로
    
    GC는 "완전 믿고 맡기는 거"는 아니고,
    
    **메모리 누수(Leak)** 같은 건 우리가 직접
    

# Reference

[[ Node.js #03 V8 아키텍처 ] Garbage Collection](https://artistdata.tistory.com/14?category=1182216)
